/*	
	 1.作用：将抽象化和实现化脱耦，使得二者可以独立变化
		 ①脱耦：脱耦就是耦合解除，耦合就是两种实体间的强关联。而这里的脱耦是指将抽象化和实现化的耦合解开，
		 或者说是将他们的强关联改为弱关联。
		 ②强关联：是编译时期就确定的，无法在运行期动态改变的关联。
		 ③弱关联：是可以动态确定并且可以在运行期改变的关联。
		 ④java中，继承是强关联，聚合是弱关联。因此，这里的脱耦就是指用聚合代替继承
	 2.java中的桥梁模式：
		 awt中Peer架构：保证UI感官与操作系统关联。每一个GUI构件都提供一个peer对象(实现化角色)，
		 这个对象是java构件在本地环境中的实现化，而每一个java构件和peer构件之间有一个Peer接口(相当于抽象实现化角色)，它们的继承结构是平级的
		 它们通过ToolKit通信。它定义出每一个java构件(详单与RefinedAbstraction)和其他peer构件之间的关系，使得构件可以动态的和任何操作系统
		 的本地构件(peer对象)发生关系。peer接口中的方法可以有空实现。这就是awt实现"write once, run anywhere"的方法。
	 3.驱动器和桥梁模式
		 ①.大多数驱动器都是桥梁模式。使用驱动器的应用就是抽象化角色，而驱动器本身是现实化角色
		 ②.JDBC驱动器:使用JDBC接口作为抽象化角色，使用不同的驱动实现作为实现化角色，其中通过DriverManger通信。
			  JDBC/ODBC这部分使用的是适配器模式。
	 4.抽象化和实现化之间通常使用一个类来通信(如:JDBC的DriverManger，它使用抽象工厂模式为桥梁模式提供实现化产品结构的创建)
	 5.适配器模式和桥梁模式的区别：前者是改变已有接口让它们可以兼容。而后者是分离抽象化和实现化，使得两者接口可以不同。
	     两个模式的努力方向是相反的
	 6.桥梁模式用来解决子类过多的方法与装饰模式不一样，它通过将原来两个基类中的实现化细节抽出来，再建造到一个实现化等级结构中，
		 然后再把原有基类改造成一个抽象化等级结构
	 7.一个桥梁模式的实现化角色可以是下一个桥梁模式的抽象化角色
	 8.多数情况下，Abstraction与RefinedAbstraction并没有区别。即不进行修正。
	 9.当有多个实现类时，在抽象化角色中应该怎样创建一个实现类的实例？
		 ①如抽象化角色知道具体化角色的所有实现类，可以在构造函数中根据参数不同创建不同实现化类。
		 ②先选用一个具体实现化角色实例化，然后再根据情况改为另一个实现化类。比如读取数据时，可以根据使用频率的上升幅度临时改用
		 另一个对大量数据处理比较合适的实现化类。
*/

/*
	 桥梁模式的应用场合：
	 1.不希望抽象部分和行为有一种固定的绑定模式，行为对抽象部分是重复的时，用桥梁模式剥离
		 eg:中杯加奶coffe  大杯加奶coffe 中杯不加奶coffe 大杯不加奶coffe。这四个类中有重复概念，可变为两个角色的组合：抽象(大杯，中杯)，
		 行为(加奶，不加奶)
	 2.使用bridge进行二进制兼容，使接口和实现分开，让它们处于不同的类层次。如接口formatInterface.jar的使用，而不关心器formatImpI.jar实现的改变
	 3.实现不一定实现接口的内容，实现同接口之间不一定一一对应，实现可能完成最原始的操作。接口通通过持有一个实现，组装
*/
public class Main {
	 public static void main(String[] args) {
		 /*
			 抽象化角色(Abstraction)：保存一个对实现化的引用(引用为protected修饰)。通过委派来实现抽象化角色中的商业方法，
			 可以达到动态改变实现化角色而达到动态得到不同功能。
			 修正抽象化角色(RefinedAbstraction)：扩展抽象化角色，改正和修改父类对抽象化角色的定义。一般有多个。
			 实现化角色(Implemention)：抽象化角色除了提供实现化角色相关的方法外还可以有别的方法，而实现化角色则往往仅为实现
			 抽象化角色的相关行为而存在。抽象化角色比实现化角色的接口宽。实现化中的每一个方法都应该有一个抽象化角色中的一个方
			 法与之对应，反之则不一定。实现化角色只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层操作。
		 */
		 Implemention impl1 =  new ConcreteImpl();
		 Implemention impl2 = new ConcreteImpl1();		 		
		 Abstraction ab1 = new RefinedAbstraction("1");
		 ab1.operation();
		 /*
			 RefinedAbstraction1中抽象化角色中的operation被置换掉了
		 */
		 RefinedAbstraction1 ab2 =  new RefinedAbstraction1();
		 ab2.setImpI(impl2);
		 ab2.operation();
		 ab2.setImpI(impl1);
		 ab2.operation();
	 }
}