import java.util.*;
/*
	1.作用:以共享的方式高效支持大量细粒度对象
	2.内蕴状态和外蕴状态:
		前者是储存在对象内部，不随环境而变化，对象创建时建立，是享元可以共享的原因
		后者是随环境而变化，不可共享的状态。它由客户端创建，在适当时传入(通过商业方法的参数传入,用以改变商业方法的行为)，
		两者是互相独立互不影响的(即传入的外蕴状态不能改变内蕴状态)
	 3.主要应用：
		①编辑器系统中，26个字母做成享元对象。内蕴状态就是单个字母(如:'A')，而字母在文本中位置和字母风格就是外蕴状态。
		②java的String是用享元模式，它的intern()方法给出字符串在共享池中的唯一实例
        
	 4.享元模式的应用场合：
		 ①一个系统有大量的对象，这些对象一共消耗大量的内存，这些对象的大部分状态可以外部化。之后，这些对象可以按照内蕴状态分成
			 很多组，当把外蕴状态剃掉后，每一个组可用一个对象代替，软件系统不依赖于对象的身份。
		 ②享元模式需要维护记录享元对象的列表，这要消耗资源。因此只有足够多得享元时才使用该模式。	
	 5.普通对象到享元对象的重构步骤：
		 ①将可以共享的状态(即所有客户端都有相同的值)和不可共享的状态(即不同的客户端会有不同的值)从常规类区分开，将不可共享的状态剔除掉。
		 ②将装换后的对象的创建交给一个工厂而非自己创建，达到对象共享的目的。
		 注：将状态移出享元对象后，这些行为仍然需要这些状态，而大多数情况状态外部化后大部分对象根本不能工作。解决办法有二：
		 1.将不能离开这些状态的行为一起移动到客户端
			 缺点：若有多个客户端，则同样的逻辑会重复出现
		 2.由客户端提供这些不能共享的状态(即在商业方法中传入不可共享状态作为参数)
	 6.享元对象不是单例对象，因为它没有引用自己，但是每一个享元只有一个实例
     
     
     7、使用场合：SAAS
            如果有一个人事管理的SAAS系统，假设A,B,C三个公司为这个SAAS的用户，则定义每个公司为这套系统的
            一个租户，每个公司又有100个员工。每个租户有自己的私有数据库。系统设计时，可以为每个租户分贝提供
            员工工资查询接口，而一个公司(租户)下的所有员工可以共享一个查询(因为一个租户下所有员工数据都存放在
            一个数据库中，它们共享数据库连接)。系统只需要3个享元实例，就可以满足300个用户的查询请求
     8、对象池和享元的区别：对象池中的对象都是等价的，任意两个对象在使用场景中都可以被对象池中其他对象
            代替。而在享元模式中，享元工厂所维护的所有对象是不同的。因此，数据库连接池使用对象池实现。
		 
*/
public class Main {
	 public static void main(String[] args) {
		 /*			 
			单纯享元模式:所有享元对象都可以共享
		 */
		 FlyWeightFactory factory = FlyWeightFactory.newInstance();
		 FlyWeight fw1 = factory.factory("A");
		 fw1.f("1");
		 FlyWeight fw2 = factory.factory("A");
		 fw2.f("2");
		 
		 
		 /*
			 1.复合享元模式：享元模式+组合模式。复合享元对象不可共享。
				原因:因为复合享元对象创建后还可以添加单纯或复合享元对象，它的状态是可以改变的，因此不能共享。
                在代码中体现的是：在factory方法中每次都新建一个CompositeFlyWeightFactory
			 2.复合享元模式中的组合模式是安全式，只有它的复合享元对象才又add和remove等方法。它的商业方法
				 循环调用它所包含的单纯享元对象的商业方法
			 3.复合享元对象不可共享，但是它们包含的单纯享元对象可以共享。
				 共享方式的设计：在享元工厂中，有两个factory方法。一个同单纯享元模式的工厂一样用来构件单纯享元对象(实现方式同单纯享元模式)，
				 另一个的参数是List，用来构件复合享元对象(List是Composite中单纯享元模式的内蕴状态的集合)。它通过遍历参数的List后在循环中调用
				 构建单纯享元对象的方法this.factory(key)来构建单纯享元，并且调用该方法的局部变量ConcreteCompositeFlyWeight的add方法(组合对象的add)进行添加，
				 之后返回ConcreteCompositeFlyWeight，这样就可以实现单纯享元共享。			 
			 4.一个复合享元对象的的所有单纯享元对象的外蕴状态都与复合享元对象的外蕴状态一致。
		 */
		 CompositeFlyWeightFactory factoryComp =  CompositeFlyWeightFactory.newInstance();
		 FlyWeight fw21 = factoryComp.factory("A");
		 FlyWeight fw22 = factoryComp.factory("B");
		 FlyWeight fw23 = factoryComp.factory("C");
		 List insideList = new ArrayList();
		 insideList.add("A");
		 insideList.add("B");
		 insideList.add("C");
		 FlyWeight fwComp = factoryComp.factory(insideList);
		 fwComp.f("1");
		 
		 
		 
		 
	 }
}