1.定义：①高层模块不应该依赖于底层模块，二者都应该依赖于抽象。
		    ②抽象不应该依赖于细节，细节应该依赖于抽象。

2.层次化：结构良好的架构应具体清晰的层定义，每个层次通过一个定义
良好的、受控的接口向外提供一组内聚服务。

依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳
定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要
稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现
类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具
体的操作，把展现细节的任务交给他们的实现类去完成。

依赖倒置中的依赖：
传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还
有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，
对依赖的传递方式一定不会陌生。

3.情形一：
   Policy---|
			    |<use>
				|
		Mechansim----|
							  |<use>
							  |
						Utilty
						
情形二：
Policy ---> (Interface) Policy Service	
							|
							|<heritance >
							|
					Mechansim---->(Interface) Mechansim Service
											           |
											           |<heritance >								
											           |
													Utility
																						
①.情形一表面上符合层次化，其实有一个隐藏的错误。Policy对其下
一直到Utility的改动都是敏感的。这种依赖关系是传递的。
②.情形二是合适的。每个高层都为它所需的服务声明一个抽象接口，
较低的层次依赖于这些抽象接口，这些高层类都通过抽象接口使用
下一层，这样高层就不会依赖于底层，底层反而依赖于高层声明的抽象
接口
③.倒置不仅仅是依赖关系上的倒置。它也是接口所有权的倒置，我们通常
会以为工具库应有自己的接口(即每个接口放在其下的一个层次)，但DIP
说明：客户拥有抽象接口，而他们的服务者则从这些接口派生。
④.DIP优点：Policy可以在定义了符合Policy Service接口的任何上下文中
重用

4.依赖于抽象：
①建议不应该依赖于具体类，所有的依赖关系都应该终止于接口或抽象类。
a.任何变量不应该持有具体类的引用
b.任何类不从具体类派生
c.任何方法都不应该覆盖任何基类中已经实现的方法

5.找出潜在抽象：
应用背后的抽象是指不随具体细节的改变而改变的真理，它是系统内部的系统。
所需服务的接口(PolicyService)并不依赖于(Policy)，任何知道如何去操作PolicyService
的对象都能控制Mechansim。

6.如果程序的依赖关系是倒置的，它就是面向对象的设计，否则是过程化设计

										
											