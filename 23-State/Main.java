/*
	 1.作用：允许一个对象在其内部状态改变的时候改变其行为
		 一个对象的行为依赖其所处状态，行为的变化伴随状态的变化
	 2.它把所研究对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象类的一个子类
	 3.它需要把系统每一个可取到的状态创立一个状态子类，当系统的状态变化时，系统便改变所选的子类
		 与一个特定状态有关的行为被包装在一个特定的对象里，使得行为定义局域化。若有新状态以及行为加入，可以不改变其他的类
	 4.它解放条件转移语句
	 5.它将系统状态变化变得明显。由于不用一些属性来指明系统所处的状态，可减少修改属性造成的错误
	 6.可以在系统不同部分使用一些相同的状态对象，这些对象都是只有行为而没有内部状态的享元对象
	 7.谁来定义状态的变化：
		 ①如果转换条件是固定的，使用context角色(MovieWithPrice)来定义
		 ②如果转换条件是灵活不固定的，使用state子类决定它的下一个继任者
			 这就需要将context对象作为参数传入state子类改变状态的方法用来引用状态
		 ③由外界决定(context以外对象)
	 8.对象的创建和湮灭
		 ①动态创建状态对象，不创立不需要的状态。一旦不需要某个状态对象，则立刻将其湮灭
			 适用于状态变化不频繁，加载状态对象成本不高，一开始不知道所使用的状态
		 ②事先创立状态对象，不湮灭它们
			 适用于状态变化比较频繁，加载状态对象成本高
	 9.抽象状态角色限定所有的表示不同状态的行为
	 10.策略模式和状态模式区别：
		 ①它们都有环境角色(context)，而后者的context中有明显的状态过渡
		 ②前者一旦选择一个具体策略类环境类在整个生命周期就不会改变对它的选择，
			 而后者则随着状态的变化而改变对具体状态类的选择，即环境类在整个生命周期会有几个不同的状态类被适用
		 
*/
public class Main {
	 public static void main(String[] args) {
		 /*
			 1.现有Movie类层次结构，若希望在程序运行时具体movie可以切换自己的分类从而得到不同的影片价格，
			 使用Movie类层次结构式不行的，因为一个对象在其生命周期是不能改变自己所属的类。
			 2.此时使用state重构为：MoiveWithPrice类层次结构，新建一个Price对象表示影片价格，MoiveWithPrice拥有这个属性
			 这时，movie对象可以随时变化它的私有属性Price的类型来达到前面的需求。
			 3.Price相当于状态角色，MoiveWithPrice相当于Context角色
		 */
		 Price price1 = new Price1();
		 Price price2 = new Price2();
		 Price price3 = new Price3();
		 MovieWithPrice movie1 = new ConMovieWithPrice1(price1);
		 movie1.showPrice();
		 movie1.setPrice(price2);
		 movie1.showPrice();
	 }
}