import java.util.*;
/*
	 1.定义：访问者模式的目的是封装一些施加于某种数据结构元素上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。
	 2.作用：
	     ①需要针对一个包含不同类型元素的聚集采取某种操作，而操作的细节根据元素类型的不同而不同时，就会出现必须对元素类型做判断的条件
		 转移语句。而访问者模式可以代替条件转移的判断
		 ②它将数据结构和用于结构上的操作耦合开来，使得操作集合可以相对自由的演化。
	 3.访问者模式的核心是双重分派(意味着施加于节点之上的操作是基于访问者和节点本身的数据类型，而不仅是其中之一)
	 4.具体访问者的数目和节点的数目没关系
	 5.适用情况：
		 ①适用于当被访问(Node)的类结构稳定的情况，它允许在Node中加入新的方法，相应的仅需加入一个具体的访问者类。而它不适合加入新的Node
		 否则需要在必须在每一个访问者中加入一个对应于访问这个新节点的方法，违反开闭原则。
		 ②系统可以按照算法和数据结构分开，即一些对象含有算法，另一些对象含有数据，接受算法的操作。如果这样的系统中有比较稳定的数据结构，又有
		 易变的算法，访问者模式就比较合适，因为访问者模式使得算法操作的增加容易。
	 6.优点：
		 ①它将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。
		 ②它可以跨几个类的等级结构访问属于不同等级结构的成员类。迭代子模式只能访问属于同一个类型等级结构的成员。
		 ③每一个单独的访问者对象都集中了相关行为，从而就可以在访问过程中将执行操作的状态积累在自己内部，而不是分散到很多节点，有利于系统维护。
	 7.缺点:
		 ①不易增加节点
		 ②破坏封装：访问者模式要求访问者对象访问并调用每一个节点对象的操作，即节点必须暴露自己的状态和操作。由于访问者对象自己积累访问操作的
		 状态，从而使这些状态不再储存在节点中，破坏封装。
	 8.实现访问者时，要尽量将尽可能多的访问逻辑放在Visitor中而不是子类中，这样子类对所访问对象的结构依赖较少，从而使维护容易。
	 9.遍历行为的归属：
		 ①ObjectStruct对象，通常做法
		 ②具体访问者对象中，一般情况下，对每一个具体访问者对象中都加入访问的逻辑是不理想的。但当遍历逻辑复杂时，不如将遍历逻辑放在具体访问者角色中。
		 
*/
public class Main {
	 public static void main(String[] args) {
		 List list = new ArrayList();
		 list.add("1");
		 list.add("2");
		 List un = Collections.unmodifiableList(list);
		 System.out.println(un);
		 list.add("3");
		 System.out.println(un);
	 }
}